# Chelsio T6 HIGH CAPACITY VF configuration file.
#
# Copyright (C) 2014-2018 Chelsio Communications.  All rights reserved.
#
#   DO NOT MODIFY THIS FILE UNDER ANY CIRCUMSTANCES.  MODIFICATION OF THIS FILE
#   WILL RESULT IN A NON-FUNCTIONAL ADAPTER AND MAY RESULT IN PHYSICAL DAMAGE
#   TO ADAPTERS.


# This file provides the default, power-on configuration for 2-port T6-based
# adapters shipped from the factory.  These defaults are designed to address
# the needs of the vast majority of Terminator customers.  The basic idea is to
# have a default configuration which allows a customer to plug a Terminator
# adapter in and have it work regardless of OS, driver or application except in
# the most unusual and/or demanding customer applications.
#
# Many of the Terminator resources which are described by this configuration
# are finite.  This requires balancing the configuration/operation needs of
# device drivers across OSes and a large number of customer application.
#
# Some of the more important resources to allocate and their constaints are:
#  1. Virtual Interfaces: 256.
#  2. Ingress Queues with Free Lists: 1024.
#  3. Egress Queues: 128K.
#  4. MSI-X Vectors: 1088.
#  5. Multi-Port Support (MPS) TCAM: 512 entries to support MAC destination
#     address matching on Ingress Packets.
#


# Global configuration settings.
#
[global]
	rss_glb_config_mode = basicvirtual
	rss_glb_config_options = tnlmapen,hashtoeplitz,tnlalllkp

	# PL_TIMEOUT register
	pl_timeout_value = 200		# the timeout value in units of us

	# The following Scatter Gather Engine (SGE) settings assume a 4KB Host
	# Page Size and a 64B L1 Cache Line Size. It programs the
	# EgrStatusPageSize and IngPadBoundary to 64B and the PktShift to 2.
	# If a Master PF Driver finds itself on a machine with different
	# parameters, then the Master PF Driver is responsible for initializing
	# these parameters to appropriate values.
	#
	# Notes:
	#  1. The Free List Buffer Sizes below are raw and the firmware will
	#     round them up to the Ingress Padding Boundary.
	#  2. The SGE Timer Values below are expressed below in microseconds.
	#     The firmware will convert these values to Core Clock Ticks when
	#     it processes the configuration parameters.
	#
	reg[0x1008] = 0x40800/0x21c70	# SGE_CONTROL
	reg[0x100c] = 0x22222222	# SGE_HOST_PAGE_SIZE
	reg[0x10a0] = 0x01040810	# SGE_INGRESS_RX_THRESHOLD
	reg[0x1044] = 4096		# SGE_FL_BUFFER_SIZE0
	reg[0x1048] = 65536		# SGE_FL_BUFFER_SIZE1
	reg[0x104c] = 1536		# SGE_FL_BUFFER_SIZE2
	reg[0x1050] = 9024		# SGE_FL_BUFFER_SIZE3
	reg[0x1054] = 9216		# SGE_FL_BUFFER_SIZE4
	reg[0x1058] = 2048		# SGE_FL_BUFFER_SIZE5
	reg[0x105c] = 128		# SGE_FL_BUFFER_SIZE6
	reg[0x1060] = 8192		# SGE_FL_BUFFER_SIZE7
	reg[0x1064] = 16384		# SGE_FL_BUFFER_SIZE8

	sge_timer_value = 5, 10, 20, 50, 100, 200 # SGE_TIMER_VALUE* in usecs
	reg[0x10c4] = 0x20000000/0x20000000 # GK_CONTROL, enable 5th thread

	# enable TP_OUT_CONFIG.IPIDSPLITMODE
	reg[0x7d04] = 0x00010000/0x00010000

	reg[0x7dc0] = 0x0e2f8849	# TP_SHIFT_CNT

	#Tick granularities in kbps
	tsch_ticks = 100000, 10000, 1000, 10

	# TP_VLAN_PRI_MAP to select filter tuples and enable ServerSram
	# filter control: compact, fcoemask
	# server sram   : srvrsram
	# filter tuples : fragmentation, mpshittype, macmatch, ethertype,
	#		  protocol, tos, vlan, vnic_id, port, fcoe
	# valid filterModes are described the Terminator 5 Data Book
	# vnicMode = pf_vf  #default. Other values are outer_vlan, encapsulation
	filterMode = fcoemask, srvrsram, fragmentation, mpshittype, protocol, vlan, port, fcoe

	# filter tuples enforced in LE active region (equal to or subset of filterMode)
	filterMask = protocol, fcoe

	# Percentage of dynamic memory (in either the EDRAM or external MEM)
	# to use for TP RX payload
	tp_pmrx = 0

	# TP RX payload page size
	tp_pmrx_pagesize = 64K

	# TP number of RX channels
	tp_nrxch = 0		# 0 (auto) = 1

	# Percentage of dynamic memory (in either the EDRAM or external MEM)
	# to use for TP TX payload
	tp_pmtx = 0

	# TP TX payload page size
	tp_pmtx_pagesize = 64K

	# TP number of TX channels
	tp_ntxch = 0		# 0 (auto) = equal number of ports

	# TP OFLD MTUs
	tp_mtus = 88, 256, 512, 576, 808, 1024, 1280, 1488, 1500, 2002, 2048, 4096, 4352, 8192, 9000, 9600

	# enable TP_OUT_CONFIG.IPIDSPLITMODE and CRXPKTENC
	reg[0x7d04] = 0x00010008/0x00010008

	# TP_GLOBAL_CONFIG
	reg[0x7d08] = 0x00000800/0x00000800 # set IssFromCplEnable

	# TP_PC_CONFIG
	reg[0x7d48] = 0x00000000/0x00000400 # clear EnableFLMError

	# TP_PARA_REG0
	reg[0x7d60] = 0x06000000/0x07000000 # set InitCWND to 6

	# LE_DB_CONFIG
	reg[0x19c04] = 0x00000000/0x00440000 # LE Server SRAM disabled
					     # LE IPv4 compression disabled 
	# LE_DB_HASH_CONFIG
	reg[0x19c28] = 0x00800000/0x01f00000 # LE Hash bucket size 8, 

	# ULP_TX_CONFIG
	reg[0x8dc0] = 0x00000104/0x00000104 # Enable ITT on PI err
					    # Enable more error msg for ...
					    # TPT error.

	# ULP_RX_MISC_FEATURE_ENABLE
	#reg[0x1925c] = 0x01003400/0x01003400 # iscsi tag pi bit
					     # Enable offset decrement after ...
					     # PI extraction and before DDP
					     # ulp insert pi source info in DIF
					     # iscsi_eff_offset_en

	#Enable iscsi completion moderation feature
	reg[0x1925c] = 0x000041c0/0x000031c0	# Enable offset decrement after
						# PI extraction and before DDP.
						# ulp insert pi source info in
						# DIF.
						# Enable iscsi hdr cmd mode.
						# iscsi force cmd mode.
						# Enable iscsi cmp mode.
	# MC configuration
	#mc_mode_brc[0] = 1		# mc0 - 1: enable BRC, 0: enable RBC

# Some "definitions" to make the rest of this a bit more readable.  We support
# 2 ports, 1 function (NIC only), scaling up to 8 "CPU Queue Sets"
# per function per port ...
#
# NMSIX = 1088			# available MSI-X Vectors
# NVI = 256			# available Virtual Interfaces
# NMPSTCAM = 512		# MPS TCAM entries
#
# NPORTS = 2			# ports
# NCPUS = 16			# CPUs we want to support scalably
# NFUNCS = 1			# functions per port (NIC)

# Breakdown of Virtual Interface/Queue/Interrupt resources for the "Unified
# PF" which many OS Drivers will use to manage most or all functions.
#
# Each Ingress Queue can use one MSI-X interrupt but some Ingress Queues can
# use Forwarded Interrupt Ingress Queues.  For these latter, an Ingress Queue
# would be created and the Queue ID of a Forwarded Interrupt Ingress Queue
# will be specified as the "Ingress Queue Asynchronous Destination Index."
# Thus, the number of MSI-X Vectors assigned to the Unified PF will be less
# than or equal to the number of Ingress Queues ...
#
# NVI_NIC = 2			# NIC access to NPORTS
# NFLIQ_NIC = 16 		# NIC Ingress Queues with Free Lists
# NETHCTRL_NIC = 20		# NIC Ethernet Control/TX Queues
# NEQ_NIC = 40			# NIC Egress Queues (FL, ETHCTRL/TX)
# NMPSTCAM_NIC = 14 		# NIC MPS TCAM Entries (NPORTS*2)
# NMSIX_NIC = 15		# NIC MSI-X Interrupt Vectors (FLIQ)
#
#

# All of the below PCI-E parameters are actually stored in various *_init.txt
# files.  We include them below essentially as comments.
#
# For PF4, we give it an MSI-X Table Size as outlined above.
#
# We want to support 256 VFs. But since we need VIs for PF as well,
# we will limit number of VIs to 248.
#
# NVF = 248

# For PF0-3 only mailbox commands are allowed and no
# resources are allocated.

[function "0"]
	wx_caps = 0x1		# PF
	r_caps = 0x81		# VF | PF
	pmask = 0x1		# access to only one port
[function "1"]
	wx_caps = 0x1		# PF
	r_caps = 0x81		# VF | PF
	pmask = 0x2		# access to only one port
[function "2"]
	wx_caps = 0x1		# PF
	r_caps = 0x81		# VF | PF
	pmask = 0x1		# access to only one port
[function "3"]
	wx_caps = 0x1		# PF
	r_caps = 0x81		# VF | PF
	pmask = 0x2		# access to only one port

# Some OS Drivers manage all application functions for all ports via PF4.
# Thus we need to provide a large number of resources here.  For Egress
# Queues we need to account for both TX Queues as well as Free List Queues
# (because the host is responsible for producing Free List Buffers for the
# hardware to consume).
#
[function "4"]
	wx_caps = all		# write/execute permissions for all commands
	r_caps = all		# read permissions for all commands
	nvi = 2			# 2 (1 per port)

	niqflint = 16 		# 7 per port + 1 fw_evt_q
	nethctrl = 20 		# 7 per port + 2 control q + 1 ptp
	neq = 40		# NEQ_NIC

	nexactf = 12 		# NMPSTCAM_NIC
	cmask = all		# access to all channels
	pmask = all		# access to all four ports ...
	protocol = nic_vm

# The following function, 1023, is not an actual PCIE function but is used to
# configure and reserve firmware internal resources that come from the global
# resource pool.
#
[function "1023"]
	wx_caps = all		# write/execute permissions for all commands
	r_caps = all		# read permissions for all commands
	nvi = 2			# 1 per port
	cmask = all		# access to all channels
	pmask = all		# access to all four ports ...
	nexactf = 4		# NPORTS + DCBX
	nfilter = 4


# For Virtual functions, we only allow NIC functionality and we only allow
# access to one port (1 << PF).  Note that because of limitations in the
# Scatter Gather Engine (SGE) hardware which checks writes to VF KDOORBELL
# and GTS registers, the number of Ingress and Egress Queues must be a power
# of 2.
#
[function "0/*"]		# NVF
	wx_caps = 0x82		# DMAQ | VF
	r_caps = 0x86		# DMAQ | VF | PORT
	nvi = 1			# 1 port
	niqflint = 4		# 3 "Queue Sets" + NXIQ
	nethctrl = 4		# 3 "Queue Sets"
	neq = 6			# 3 "Queue Sets" * 2
	nexactf = 2
	cmask = all		# access to all channels
	pmask = 0x1		# access to only one port ...


[function "1/*"]		# NVF
	wx_caps = 0x82		# DMAQ | VF
	r_caps = 0x86		# DMAQ | VF | PORT
	nvi = 1			# 1 port
	niqflint = 4		# 3 "Queue Sets" + fw evt q
	nethctrl = 4		# 3 "Queue Sets"
	neq = 6			# 3 "Queue Sets" * 2
	nexactf = 2
	cmask = all		# access to all channels
	pmask = 0x2		# access to only one port ...

[function "2/*"]		# NVF
	wx_caps = 0x82		# DMAQ | VF
	r_caps = 0x86		# DMAQ | VF | PORT
	nvi = 1			# 1 port
	niqflint = 4		# 3 "Queue Sets" + NXIQ
	nethctrl = 4		# 3 "Queue Sets"
	neq = 6			# 3 "Queue Sets" * 2
	nexactf = 2
	cmask = all		# access to all channels
	pmask = 0x1		# access to only one port ...


[function "3/*"]		# NVF
	wx_caps = 0x82		# DMAQ | VF
	r_caps = 0x86		# DMAQ | VF | PORT
	nvi = 1			# 1 port
	niqflint = 4		# 3 "Queue Sets" + NXIQ
	nethctrl = 4		# 3 "Queue Sets"
	neq = 6			# 3 "Queue Sets" * 2
	nexactf = 2
	cmask = all		# access to all channels
	pmask = 0x2		# access to only one port ...

# MPS features a 196608 bytes ingress buffer that is used for ingress buffering
# for packets from the wire as well as the loopback path of the L2 switch. The
# folling params control how the buffer memory is distributed and the L2 flow
# control settings:
#
# bg_mem:	%-age of mem to use for port/buffer group
# lpbk_mem:	%-age of port/bg mem to use for loopback
# hwm:		high watermark; bytes available when starting to send pause
#		frames (in units of 0.1 MTU)
# lwm:		low watermark; bytes remaining when sending 'unpause' frame
#		(in inuits of 0.1 MTU)
# dwm:		minimum delta between high and low watermark (in units of 100
#		Bytes)
#
[port "0"]
	dcb = ppp, dcbx		# configure for DCB PPP and enable DCBX offload
	#bg_mem = 25
	#lpbk_mem = 25
	hwm = 60
	lwm = 15
	dwm = 30
	dcb_app_tlv[0] = 0x8906, ethertype, 3
	dcb_app_tlv[1] = 0x8914, ethertype, 3
	dcb_app_tlv[2] = 3260, socketnum, 5

[port "1"]
	dcb = ppp, dcbx
	#bg_mem = 25
	#lpbk_mem = 25
	hwm = 60
	lwm = 15
	dwm = 30
	dcb_app_tlv[0] = 0x8906, ethertype, 3
	dcb_app_tlv[1] = 0x8914, ethertype, 3
	dcb_app_tlv[2] = 3260, socketnum, 5

[fini]
	version = 0x1200002c
	checksum = 0xd1b8a489

# Total resources used by above allocations:
#   Virtual Interfaces: 250
#   Ingress Queues/w Free Lists and Interrupts: 1008
#   Egress Queues: 1528
#   MPS TCAM Entries: 512
#   MSI-X Vectors: 1008
#   Virtual Functions: 248
